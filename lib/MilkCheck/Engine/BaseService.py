# Copyright CEA (2011) 
# Contributor: TATIBOUET Jeremie <tatibouetj@ocre.cea.fr>

"""
This module contains the definition of the Base class of a service and the
defnition of the different states that a service can go through
"""

# Classes
from MilkCheck.Engine.BaseEntity import BaseEntity
from ClusterShell.Event import EventHandler
from ClusterShell.Task import task_self

# Exceptions
from exceptions import Exception
from MilkCheck.Engine.BaseEntity import MilkCheckEngineError

"""
Symbols defining the differents status of a service
"""
NO_STATUS = "NO_STATUS"
IN_PROGRESS = "IN_PROGRESS"
SUCCESS = "SUCCESS"
SUCCESS_WITH_WARNINGS = "SUCESS_WITH_WARNINGS"
TIMED_OUT = "TIMED_OUT"
TOO_MANY_ERROR = "TOO_MANY_ERROR"
ERROR = "ERROR"

class IllegalDependencyIdentifierError(MilkCheckEngineError):
    """
    Exception raised when you try to use another keyword than require
    or check for a depdency
    """
    
    def __init__(self, message="You have to use require or check"):
        """Constructor"""
        MilkCheckEngineError.__init__(self, message)

class BaseService(BaseEntity, EventHandler):
    """
    This class is abstract and define the method that a service or a 
    group of service has to implement. In implementing an EventHandler
    this class can handler events generated by ClusterShell.
    """
    
    def __init__(self, name):
        BaseEntity.__init__(self, name)
        EventHandler.__init__(self)
        
        # Define the initial status
        self.status = NO_STATUS
        
        # Define the task
        self._task = task_self()
        
        # Define the last action called on the service
        self._last_action = "unknow"
        
        # Require type dependencies 
        self._requires = {}
        
        # Check type dependencies
        self._checks = {}
       
    
    def add_dependency(self, service, dep_type="require", obl=True):
        """
        Add the dependency in the right dictionnary
        """
        if service:
            dep_type = dep_type.lower()
            if dep_type == "require":
                self._requires[service.name] = (service, "require", obl)
                service.add_child(self)
            elif dep_type == "check":
                self._checks[service.name] = (service, "check", True)
                service.add_child(self)
            else:
                raise IllegalDependencyIdentifierError()
        else:
            raise TypeError("service cannot be None") 
    
    def _remaining_dependencies(self):
        """
        Analyze dependencies and returns either those which
        have NO_STATUS and thos which are IN_PROGRESS
        """
        remaining = []
        for rname in self._requires:
            if self._requires[rname][0].status in (NO_STATUS, IN_PROGRESS):
                remaining.append(self._requires[rname])
        for cname in self._checks:
            if self._checks[cname][0].status in (NO_STATUS, IN_PROGRESS):
                remaining.append(self._checks[cname])
        return remaining
            
    def _has_in_progress_dep(self):
        """
        Allow us to determine if the current services
        has to wait before to start due to unterminated
        dependencies
        """
        for rname in self._requires:
            if self._requires[rname][0].status == IN_PROGRESS:
                return True
        for cname in self._checks:
            if self._checks[cname][0].status == IN_PROGRESS:
                return True
        return False
                
    def is_check_dep(self, service):
        """
        Evaluate if the dependency given as a parameter is check
        """
        return service.name in self._checks
        
    def is_require_dep(self, service):
        """
        Evaluate if the dependency given as a parameter is require
        """
        return service.name in self._requires

    def cleanup_dependencies(self):
        """
        Clean check and require dependencies
        """
        self._requires.clear()
        self._checks.clear()
        
    def prepare(self, action_name = None):
        """
        Abstract method which will be overriden in Service and ServiceGroup
        """
        raise NotImplementedError

    def update_status(self, status):
        """
        Update the status of a service and launch his dependencies
        """
        self.status = status 
        print "["+self.name+"] is ["+self.status+"]"
      
        if self.status not in (NO_STATUS, IN_PROGRESS):
            # The action performed on the current service
            # had some issues
            for child in self.children:
                if self.status == ERROR :
                     if child.is_check_dep(self) or \
                        child._requires[self.name][2]:
                        child.status = ERROR
                else:
                   if child.status == NO_STATUS and \
                        not child._has_in_progress_dep():
                        print  "** "+self.name+" fires "+child.name
                        child.prepare()
    
    def run(self, action_name):
        """
        Run the action_name over the current service
        """
        self.prepare(action_name)
        self.resume()
        
    def resume(self):
        """
        Start the execution of the tasks on the nodes specified
        """
        self._task.resume()
    
    def ev_hup(self, worker):
        """
        Called to indicate that a worker's connection has been closed.
        """
        raise NotImplementedError
    
    def ev_close(self, worker):
        """
        Called to indicate that a worker has just finished (it may already
        have failed on timeout).
        """
        raise NotImplementedError