# Copyright CEA (2011) 
# Contributor: TATIBOUET Jeremie <tatibouetj@ocre.cea.fr>

"""
This module contains the definition of the Base class of a service and the
defnition of the different states that a service can go through
"""

# Classes
from MilkCheck.Engine.BaseEntity import BaseEntity
from ClusterShell.Task import task_self

# Symbols
from MilkCheck.Engine.Dependency import CHECK, REQUIRE, REQUIRE_WEAK
from MilkCheck.Engine.BaseEntity import TIMED_OUT, TOO_MANY_ERRORS
from MilkCheck.Engine.BaseEntity import DONE, DONE_WITH_WARNINGS
from MilkCheck.Engine.BaseEntity import NO_STATUS, WAITING_STATUS, ERROR

"""
Symbols defining the differents status of a service
"""

class BaseService(BaseEntity):
    """
    This class is abstract and define the method that a service or a 
    group of service has to implement. In implementing an EventHandler
    this class can handler events generated by ClusterShell.
    """
    
    def __init__(self, name):
        BaseEntity.__init__(self, name)
        
        # Define whether the service has warnings
        self.warnings = False
        
        # Define the last action called on the service
        self._last_action = None
        
        # Define a flag allowing us to specify that this service
        # is the original caller so we do not have to start his
        # children 
        self.origin = False
                   
            
    def eval_deps_status(self, reverse=False):
        """
        Evaluate the result of the dependencies in order to check
        if we have to continue in normal mode or in a degraded mode.
        """
        deps = self.parents
        if reverse:
            deps = self.children
            
        temp_dep_status = DONE
        for dep_name in deps:
            if deps[dep_name].target.status in \
                (TOO_MANY_ERRORS, TIMED_OUT, ERROR):
                if deps[dep_name].is_strong():
                    return ERROR
                else:
                    temp_dep_status = DONE_WITH_WARNINGS
            elif deps[dep_name].target.status == WAITING_STATUS:
                return WAITING_STATUS
            elif deps[dep_name].target.status == NO_STATUS:
                temp_dep_status = NO_STATUS
        return temp_dep_status
        
    def update_status(self, status, reverse=False):
        """
        Update the current service's status and can trigger his dependencies.
        """
        assert status in (TIMED_OUT, TOO_MANY_ERRORS, DONE, \
                            DONE_WITH_WARNINGS, NO_STATUS, WAITING_STATUS, \
                                ERROR) 
        self.status = status 
        print "[%s] is [%s]" % (self.name, self.status)
        
        # I got a status so I'm DONE or ERROR and I'm not the calling point
        if self.status not in (NO_STATUS, WAITING_STATUS) and not self.origin:
            
            # Trigger each service which depend on me as soon as it does not
            # have WAITING_STATUS parents 
            deps = self.children
            if reverse:
                deps = self.parents
                
            for depname in deps:
                if deps[depname].target.status == NO_STATUS and \
                    not deps[depname].target.has_waiting_deps(reverse):
                    print  "*** %s triggers %s" % (self.name, \
                        deps[depname].target.name)
                    deps[depname].target.prepare()
    
    def run(self, action_name):
        """Run the action_name over the current service."""
        
        # A service using run become the calling point
        self.origin = True
        
        # Prepare the service and start the master task
        if action_name == 'stop':   
            self.prepare(action_name, reverse=True)
        else:
            self.prepare(action_name)
        self.resume()
        
    def resume(self):
        """Start the execution of the tasks on the nodes specified."""
        task_self().resume()
        
    def prepare(self, action_name=None, reverse=False):
        """
        Abstract method which will be overriden in Service and ServiceGroup.
        """
        raise NotImplementedError