# Copyright CEA (2011)
# Contributor: TATIBOUET Jeremie <tatibouetj@ocre.cea.fr>

'''
This module contains the UserView class definition.
'''

# classes
from sys import stderr, stdout
from MilkCheck.UI.UserView import UserView
from MilkCheck.UI.OptionParser import McOptionParser
from MilkCheck.UI.OptionParser import InvalidOptionError
from MilkCheck.Engine.Action import Action, NodeInfo
from MilkCheck.Engine.Service import Service
from MilkCheck.ServiceManager import service_manager_self

class CommandLineInterface(UserView):
    '''
    This class models the Command Line Interface which is a UserView. From
    this class you can get back events generated by the engine and send order
    to the ServiceManager.
    '''

    def __init__(self):
        UserView.__init__(self)
        # Parser which reads the command line
        self._mop = None
        # Store the options parsed
        self._options = None
        # Store the arguments parsed
        self._args = None
        # Profiling mode (help in unit tests)
        self.profiling = False
        # Used in profiling mode
        # Each counter match to a verbosity level
        self.count_low_verbmsg = 0
        self.count_average_verbmsg = 0
        self.count_high_verbmsg = 0

    def execute(self, command_line):
        '''
        Ask for the manager to execute orders given by the command line.
        '''
        self._mop = McOptionParser()
        self._mop.configure_mop()
        try:
            (self._options, self._args) = self._mop.parse_args(command_line)
        except InvalidOptionError as exc:
            stderr.write(exc.msg)
        else:
            manager = service_manager_self()
            self.count_low_verbmsg = 0
            self.count_average_verbmsg = 0
            self.count_high_verbmsg = 0
            # Case 1 : we call services and we are able to add constraints
            if len(self._args) > 1:
                manager.call_services(
                    self._args[:len(self._args)-1], self._args[-1],
                        opts=self._options)
            # Case 2 : we just display dependencies of one or several services
            elif self._options.print_servs:
                print 'Print service dependencies'
            # Case 3 : Just load another configuration into the manager
            else:
                print 'Load another configuration'
        finally:
            self._mop.destroy()
    
    def ev_started(self, obj):
        '''
        Something has started on the object given as parameter. This migh be
        the beginning of a command one a node, an action or a service.
        '''
        if isinstance(obj, NodeInfo) and self._options.verbosity >= 3:
            pass
        elif isinstance(obj, Action) and self._options.verbosity >= 2:
            print " >>> [%s] action [%s] in Task" % \
            (obj.service.name, obj.name)
            if self.profiling:
                self.count_average_verbmsg += 1
        elif isinstance(obj, Service) and self._options.verbosity >= 1:
            print '[%s] processing has started' % obj.name
            if self.profiling:
                self.count_low_verbmsg += 1
                
    def ev_complete(self, obj):
        '''
        Something is complete on the object given as parameter. This migh be
        the end of a command on a node,  an action or a service.
        '''
        if isinstance(obj, NodeInfo) and self._options.verbosity >= 3:
            print '    ===> %s' % obj
            if obj.node_buffer:
                print '         [buffer]'
                print '             %s', obj.node_buffer
            if self.profiling:
                self.count_high_verbmsg += 1
        elif isinstance(obj, Action) and self._options.verbosity >= 2:
            print " >>> [%s] action [%s] processed in %f s" % \
            (obj.service.name, obj.name, obj.duration)
            if self.profiling:
                self.count_average_verbmsg += 1
        elif isinstance(obj, Service) and self._options.verbosity >= 1:
            print "[%s] has been processed" % obj.name
            if self.profiling:
                self.count_low_verbmsg += 1

    def ev_status_changed(self, obj):
        '''
        Status of the object given as parameter. Actions or Service's status
        might have changed.
        '''
        if isinstance(obj, Action) and self._options.verbosity >= 2:
            print " >>> [%s] action [%s] is [%s] " % \
            (obj.service.name, obj.name, obj.status)
            if self.profiling:
                self.count_average_verbmsg += 1
        elif isinstance(obj, Service) and self._options.verbosity >= 1:
            print " >>> [%s] status is [%s] " % (obj.name, obj.status)
            if self.profiling:
                self.count_low_verbmsg += 1
    def ev_delayed(self, obj):
        '''
        Object given as parameter has been delayed. This event is only raised
        when an action was delayed
        '''
        if isinstance(obj, Action) and self._options.verbosity >= 2:
            print " >>> [%s] action [%s] has been delayed %i s" % \
            (obj.service.name, obj.name, obj.delay)
            if self.profiling:
                self.count_average_verbmsg += 1
                
    def ev_trigger_dep(self, obj_source, obj_triggered):
        '''
        obj_source/obj_triggered might be an action or a service. This
        event is raised when the obj_source triggered another object. Sample :
        Action A triggers Action B
        Service A triggers Service B
        '''
        if isinstance(obj_source, Action) and \
                isinstance(obj_triggered, Action) and \
                    self._options.verbosity >= 2:
            print '[%s] Action [%s] triggers Action [%s]' % \
            (obj_source.service.name, obj_source.name, obj_triggered.name)
            if self.profiling:
                self.count_average_verbmsg += 1
        elif isinstance(obj_source, Service) and \
                isinstance(obj_triggered, Service) and \
                    self._options.verbosity >= 1:
            print '[%s] triggers [%s]' % (obj_source.name, obj_triggered.name)
            if self.profiling:
                self.count_low_verbmsg += 1

    def get_totalmsg_count(self):
        '''Sum all counter to know how many message the CLI got'''
        return  (self.count_low_verbmsg + \
                    self.count_average_verbmsg + \
                        self.count_high_verbmsg)

    total_msg_count = property(fget=get_totalmsg_count)